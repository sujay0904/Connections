<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Our Own Connections</title>
  <!--
    Implementation notes
    - Endless run of Connections-style puzzles
    - Per-puzzle: 4 mistakes; every wrong guess (incl. "One away!") costs 1 mistake and –25 points
    - Repeated wrong combination does NOT cost a mistake (we show a notice)
    - Score per solved puzzle: 100 / 75 / 50 / 25 (min 0). Losing puzzle scores 0.
    - Streak = number of puzzles solved in current run. Shown live and on leaderboard.
    - Anti-repeat within a run: track used puzzle IDs; re-roll if already seen. If we run out, we reset the set.
    - Win/Lose: show quick image overlay for 2 seconds, then continue (win → next puzzle; lose → final screen)
    - Styling mirrors NYT Connections feel (adjust colour variables below if you want pixel-perfect).
    - Puzzles are expected from an external `puzzles.js` file that defines `window.CONNECTIONS_PUZZLES`.
      A minimal fallback sample is included for previewing if that file is absent.
  -->

  <style>
    :root {
      /* Adjust these to more closely match NYT Connections palette if desired */
      --bg: #f6f6f5;
      --text: #111;
      --muted: #777;
      --tile-bg: #e7e7e7;
      --tile-border: #d0d0d0;
      --tile-hover: #dcdcdc;
      --tile-selected-bg: #333;
      --tile-selected-text: #fff;
      --btn-bg: #111;
      --btn-text: #fff;
      --btn-disabled-bg: #bbb;
      --btn-disabled-text: #fff;

      /* Category colours (tweak as needed) */
      --cat-yellow: #f7da21;
      --cat-green: #6ac36f;
      --cat-blue:  #6aa7ff;
      --cat-purple:#b084f9;
    }

    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg);
      color: var(--text);
      display: grid;
      grid-template-rows: auto 1fr auto;
      min-height: 100vh;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px clamp(12px, 4vw, 32px);
      border-bottom: 1px solid #e2e2e2;
      gap: 12px;
    }
    .brand {
      font-weight: 800;
      letter-spacing: 0.5px;
      font-size: 20px;
    }
    .status {
      display: flex;
      gap: 14px;
      font-size: 14px;
      color: var(--muted);
    }
    .status b { color: var(--text); }

    main {
      width: min(900px, 92vw);
      margin: 18px auto 28px;
    }

    #solvedArea { display: grid; gap: 10px; margin-bottom: 16px; }
    .solved-row {
      display: grid;
      grid-template-columns: 140px 1fr;
      align-items: center;
      border-radius: 10px;
      padding: 8px 10px;
      font-weight: 600;
      color: #111;
      box-shadow: 0 1px 0 rgba(0,0,0,0.05);
    }
    .solved-row .label { opacity: 0.9; }
    .solved-row .words { opacity: 0.95; }

    .cat-yellow { background: color-mix(in oklab, var(--cat-yellow) 45%, white); }
    .cat-green  { background: color-mix(in oklab, var(--cat-green) 45%, white); }
    .cat-blue   { background: color-mix(in oklab, var(--cat-blue) 45%, white); }
    .cat-purple { background: color-mix(in oklab, var(--cat-purple) 45%, white); }

    /* Grid */
    .grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    }
    .tile {
      user-select: none;
      background: var(--tile-bg);
      border: 1px solid var(--tile-border);
      border-radius: 10px;
      padding: 18px 10px;
      text-align: center;
      font-weight: 700;
      letter-spacing: 0.2px;
      cursor: pointer;
      transition: transform 120ms ease, background 120ms ease, color 120ms ease, border-color 120ms ease;
    }
    .tile:hover { background: var(--tile-hover); }
    .tile.selected {
      background: var(--tile-selected-bg);
      color: var(--tile-selected-text);
      border-color: #000;
      transform: translateY(-1px);
    }
    .tile.locked { opacity: 0.35; pointer-events: none; }

    /* Controls */
    .controls {
      display: flex;
      gap: 10px;
      margin: 16px 0 10px;
    }
    button {
      appearance: none;
      border: none;
      background: var(--btn-bg);
      color: var(--btn-text);
      padding: 10px 14px;
      border-radius: 999px;
      font-weight: 700;
      letter-spacing: 0.2px;
      cursor: pointer;
    }
    button.secondary { background: #ddd; color: #111; }
    button:disabled { background: var(--btn-disabled-bg); color: var(--btn-disabled-text); cursor: not-allowed; }

    .hud {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-top: 6px;
    }

    .mistakes {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .dot { width: 10px; height: 10px; border-radius: 50%; background: #ccc; }
    .dot.live { background: #111; }

    #feedback { min-height: 24px; margin-top: 8px; color: var(--muted); font-weight: 600; }

    .toast {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: 24px; background: #111; color: #fff; padding: 10px 14px; border-radius: 999px;
      font-weight: 700; letter-spacing: 0.2px; opacity: 0; pointer-events: none; transition: opacity 200ms ease;
    }
    .toast.show { opacity: 1; }

    .shake { animation: shake 250ms ease; }
    @keyframes shake {
      0%{ transform: translateX(0); }
      25%{ transform: translateX(-3px); }
      50%{ transform: translateX(3px); }
      75%{ transform: translateX(-3px); }
      100%{ transform: translateX(0); }
    }

    /* Overlays for win/lose images */
    .overlay {
      position: fixed; inset: 0; display: grid; place-items: center; background: rgba(0,0,0,0.35);
      opacity: 0; pointer-events: none; transition: opacity 200ms ease;
    }
    .overlay img { width: min(60vmin, 360px); height: auto; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.35); }
    .overlay.show { opacity: 1; pointer-events: auto; }

    /* Game Over panel */
    .modal {
      position: fixed; inset: 0; display: grid; place-items: center; background: rgba(0,0,0,0.15);
      opacity: 0; pointer-events: none; transition: opacity 200ms ease;
    }
    .modal.show { opacity: 1; pointer-events: auto; }
    .card {
      width: min(520px, 92vw);
      background: #fff; border-radius: 16px; padding: 18px; box-shadow: 0 8px 40px rgba(0,0,0,0.18);
    }
    .card h2 { margin: 6px 0 12px; }
    .row { display: flex; gap: 12px; align-items: center; justify-content: space-between; }
    .field { display: grid; gap: 6px; margin: 10px 0; }
    input[type="text"] { padding: 10px 12px; border-radius: 10px; border: 1px solid #ccc; font-size: 15px; }

    /* Leaderboard */
    #leaderboard { margin: 32px 0 24px; }
    #leaderboard h3 { margin-bottom: 8px; }
    table { width: 100%; border-collapse: collapse; background: #fff; border-radius: 12px; overflow: hidden; }
    th, td { padding: 10px 12px; border-bottom: 1px solid #eee; text-align: left; font-size: 14px; }
    th { background: #f1f1f1; font-weight: 800; }

    footer { padding: 16px clamp(12px, 4vw, 32px); border-top: 1px solid #e2e2e2; color: var(--muted); font-size: 13px; }
  </style>
</head>
<body>
  <header>
    <div class="brand">Connections</div>
    <div class="status" aria-live="polite">
      <div>Total score: <b id="totalScore">0</b></div>
      <div>Streak: <b id="streak">0</b></div>
      <div>Puzzles solved: <b id="puzzlesSolved">0</b></div>
    </div>
  </header>

  <main>
    <div id="solvedArea" aria-live="polite"></div>

    <section class="grid" id="grid" aria-label="Word tiles"></section>

    <div class="controls">
      <button class="secondary" id="shuffleBtn" aria-label="Shuffle tiles">Shuffle</button>
      <button class="secondary" id="clearBtn" aria-label="Clear selection">Deselect</button>
      <button id="submitBtn" disabled aria-label="Submit selection">Submit</button>
    </div>

    <div class="hud">
      <div class="mistakes" id="mistakes" aria-label="Mistakes remaining">
        <div class="dot live"></div>
        <div class="dot live"></div>
        <div class="dot live"></div>
        <div class="dot live"></div>
      </div>
      <div id="feedback" role="status" aria-live="polite"></div>
    </div>

    <section id="leaderboard">
      <h3>Leaderboard</h3>
      <div id="leaderboardTableWrap"></div>
    </section>
  </main>

  <div id="winOverlay" class="overlay" aria-hidden="true">
    <img id="puzzleWinImage" src="win-placeholder.png" alt="Puzzle solved" />
  </div>
  <div id="loseOverlay" class="overlay" aria-hidden="true">
    <img id="gameOverImage" src="gameover-placeholder.png" alt="Game over" />
  </div>

  <div id="gameOverModal" class="modal" aria-hidden="true">
    <div class="card" role="dialog" aria-labelledby="gomTitle" aria-describedby="gomDesc">
      <h2 id="gomTitle">Run complete</h2>
      <p id="gomDesc" class="muted">Submit your score to the leaderboard.</p>
      <div class="row">
        <div><strong>Total score:</strong> <span id="finalTotalScore">0</span></div>
        <div><strong>Streak:</strong> <span id="finalStreak">0</span></div>
      </div>
      <div class="field">
        <label for="playerName">Your name</label>
        <input id="playerName" type="text" placeholder="e.g., Alex" maxlength="24" />
      </div>
      <div class="row">
        <button id="submitScoreBtn">Submit to Leaderboard</button>
        <button class="secondary" id="playAgainBtn">Play again</button>
      </div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <!-- Load your external puzzles file here. Expected to define window.CONNECTIONS_PUZZLES -->
  <script src="puzzles.js"></script>

  <script>
    // --- Fallback puzzles (for preview if puzzles.js is missing) ---
    if (!window.CONNECTIONS_PUZZLES) {
      window.CONNECTIONS_PUZZLES = [
        {
          id: "SAMPLE-001",
          categories: [
            { name: "Feline Things", color: "yellow", words: ["CAT", "WHISKER", "PURR", "PAW"] },
            { name: "Weather Words", color: "green", words: ["RAIN", "CLOUD", "SUN", "WIND"] },
            { name: "Containers", color: "blue", words: ["JAR", "TIN", "BOX", "CAN"] },
            { name: "Verbs of Movement", color: "purple", words: ["RUN", "LEAP", "WALK", "ROLL"] }
          ]
        },
        {
          id: "SAMPLE-002",
          categories: [
            { name: "Currency", color: "yellow", words: ["POUND", "EURO", "YEN", "RUPEE"] },
            { name: "Birds", color: "green", words: ["CROW", "FINCH", "SWAN", "OWL"] },
            { name: "Kitchen Items", color: "blue", words: ["PAN", "POT", "GRATER", "LADLE"] },
            { name: "Shades of Blue", color: "purple", words: ["TEAL", "NAVY", "CYAN", "AZURE"] }
          ]
        }
      ];
    }

    // --- Utilities ---
    const $ = (sel, root=document) => root.querySelector(sel);
    const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
    const shuffleArray = (arr) => arr.map(v=>[Math.random(), v]).sort((a,b)=>a[0]-b[0]).map(p=>p[1]);
    const sleep = (ms) => new Promise(r=>setTimeout(r, ms));

    function keyFromWords(words) {
      return words.slice().sort().join("|");
    }

    // --- State ---
    const state = {
      totalScore: 0,
      puzzlesSolved: 0,
      streak: 0,
      current: null,         // current puzzle bundle
      selectedIds: new Set(),
      wrongCombos: new Set(), // keys of prior wrong submissions for this puzzle
      mistakesLeft: 4,
      wrongGuesses: 0,
      usedPuzzleIds: new Set(), // to avoid repeats within a run
    };

    // --- DOM refs ---
    const gridEl = $('#grid');
    const solvedAreaEl = $('#solvedArea');
    const feedbackEl = $('#feedback');
    const mistakesEl = $('#mistakes');
    const submitBtn = $('#submitBtn');
    const shuffleBtn = $('#shuffleBtn');
    const clearBtn = $('#clearBtn');

    const totalScoreEl = $('#totalScore');
    const puzzlesSolvedEl = $('#puzzlesSolved');
    const streakEl = $('#streak');

    const winOverlay = $('#winOverlay');
    const loseOverlay = $('#loseOverlay');
    const gameOverModal = $('#gameOverModal');
    const finalTotalScoreEl = $('#finalTotalScore');
    const finalStreakEl = $('#finalStreak');
    const playerNameInput = $('#playerName');
    const submitScoreBtn = $('#submitScoreBtn');
    const playAgainBtn = $('#playAgainBtn');
    const toastEl = $('#toast');

    // --- Leaderboard storage ---
    const LB_KEY = 'connections_leaderboard_v1';
    const NAME_KEY = 'connections_player_name_v1';

    function loadLeaderboard() {
      try { return JSON.parse(localStorage.getItem(LB_KEY) || '[]'); } catch { return []; }
    }
    function saveLeaderboard(list) {
      localStorage.setItem(LB_KEY, JSON.stringify(list));
    }

    function showToast(msg, ms=1400) {
      toastEl.textContent = msg;
      toastEl.classList.add('show');
      setTimeout(()=>toastEl.classList.remove('show'), ms);
    }

    function updateHud() {
      totalScoreEl.textContent = state.totalScore;
      puzzlesSolvedEl.textContent = state.puzzlesSolved;
      streakEl.textContent = state.streak;
    }

    function renderMistakes() {
      const dots = $$('.dot', mistakesEl);
      dots.forEach((d, i) => {
        d.classList.toggle('live', i < state.mistakesLeft);
      });
    }

    function setFeedback(msg) {
      feedbackEl.textContent = msg || '';
    }

    function clearSelection() {
      state.selectedIds.clear();
      $$('.tile').forEach(t => t.classList.remove('selected'));
      submitBtn.disabled = true;
    }

    function buildTilesFromCategories(categories) {
      // Build unique tile objects avoiding duplicate-word collision by suffixing an index
      const tiles = [];
      const counts = new Map();
      for (const cat of categories) {
        for (const w of cat.words) {
          const up = String(w).toUpperCase();
          const n = (counts.get(up) || 0) + 1;
          counts.set(up, n);
          tiles.push({ id: `${up}#${n}`, text: up });
        }
      }
      return tiles;
    }

    function chooseNextPuzzle() {
      const pool = window.CONNECTIONS_PUZZLES;
      if (!pool || pool.length === 0) throw new Error('No puzzles available.');
      const unseen = pool.filter(p => !state.usedPuzzleIds.has(p.id));
      const pick = (unseen.length ? unseen : pool)[Math.floor(Math.random()* (unseen.length ? unseen.length : pool.length))];
      if (!unseen.length) state.usedPuzzleIds.clear(); // reset if we exhausted all
      state.usedPuzzleIds.add(pick.id);
      return pick;
    }

    function colorClass(color) {
      switch((color||'').toLowerCase()) {
        case 'yellow': return 'cat-yellow';
        case 'green': return 'cat-green';
        case 'blue': return 'cat-blue';
        case 'purple': return 'cat-purple';
        default: return 'cat-yellow';
      }
    }

    function renderSolvedRow(cat) {
      const row = document.createElement('div');
      row.className = `solved-row ${colorClass(cat.color)}`;
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = cat.name;
      const words = document.createElement('div');
      words.className = 'words';
      words.textContent = cat.words.join(' • ');
      row.append(label, words);
      solvedAreaEl.appendChild(row);
    }

    function renderGrid(tiles) {
      gridEl.innerHTML = '';
      tiles.forEach(t => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'tile';
        btn.dataset.id = t.id;
        btn.dataset.word = t.text;
        btn.textContent = t.text;
        btn.addEventListener('click', () => onTileClick(btn));
        gridEl.appendChild(btn);
      });
    }

    function shuffleGrid() {
      const children = Array.from(gridEl.children);
      const shuffled = shuffleArray(children);
      gridEl.innerHTML = '';
      shuffled.forEach(el => gridEl.appendChild(el));
    }

    function onTileClick(btn) {
      if (btn.classList.contains('locked')) return;
      const id = btn.dataset.id;
      if (state.selectedIds.has(id)) {
        state.selectedIds.delete(id);
        btn.classList.remove('selected');
      } else {
        if (state.selectedIds.size >= 4) return; // max 4
        state.selectedIds.add(id);
        btn.classList.add('selected');
      }
      submitBtn.disabled = state.selectedIds.size !== 4;
    }

    function getSelectedWords() {
      return Array.from(state.selectedIds).map(id => id.split('#')[0]);
    }

    function lockCategoryWords(words) {
      // Mark tiles as locked and fade
      const wordSet = new Set(words.map(w => String(w).toUpperCase()));
      $$('.tile').forEach(t => {
        if (wordSet.has(t.dataset.word)) t.classList.add('locked');
      });
    }

    function allCategoriesSolved() {
      return state.current.solvedCats.length === 4;
    }

    function anyOneAway(selSet) {
      for (const cat of state.current.unsolvedCats()) {
        const inter = cat.words.filter(w => selSet.has(String(w).toUpperCase())).length;
        if (inter === 3) return true;
      }
      return false;
    }

    function shakeSelection() {
      $$('.tile.selected').forEach(t => {
        t.classList.remove('shake');
        void t.offsetWidth; // reflow
        t.classList.add('shake');
      });
    }

    async function submitSelection() {
      if (state.selectedIds.size !== 4) return;
      const words = getSelectedWords();
      const key = keyFromWords(words);

      // Check if already-guessed wrong combo
      if (state.wrongCombos.has(key)) {
        showToast('Already guessed this combination');
        shakeSelection();
        return; // DO NOT consume mistake
      }

      // Check correctness
      const match = state.current.unsolvedCats().find(cat => {
        const a = new Set(cat.words.map(w => String(w).toUpperCase()));
        return words.every(w => a.has(String(w).toUpperCase()));
      });

      if (match) {
        // CORRECT
        renderSolvedRow(match);
        lockCategoryWords(match.words);
        state.current.solvedCats.push(match);
        setFeedback(`${match.name}`);
        clearSelection();

        if (allCategoriesSolved()) {
          // Compute score for this puzzle
          const puzzleScore = Math.max(0, 100 - 25 * state.wrongGuesses);
          state.totalScore += puzzleScore;
          state.puzzlesSolved += 1;
          state.streak += 1;
          updateHud();
          await showWinOverlayThenNext();
        }
        return;
      }

      // INCORRECT or ONE AWAY
      const selSet = new Set(words.map(w => String(w).toUpperCase()));
      const isOneAway = anyOneAway(selSet);

      // Record as a wrong combo to prevent repeated penalty
      state.wrongCombos.add(key);

      state.wrongGuesses += 1;
      state.mistakesLeft -= 1;
      renderMistakes();
      setFeedback(isOneAway ? 'One away!' : 'Incorrect group.');
      shakeSelection();
      clearSelection();

      if (state.mistakesLeft <= 0) {
        await showLoseOverlayThenGameOver();
      }
    }

    async function showWinOverlayThenNext() {
      winOverlay.classList.add('show');
      await sleep(2000);
      winOverlay.classList.remove('show');
      await loadNextPuzzle();
    }

    async function showLoseOverlayThenGameOver() {
      loseOverlay.classList.add('show');
      await sleep(2000);
      loseOverlay.classList.remove('show');
      // Show final screen
      finalTotalScoreEl.textContent = state.totalScore;
      finalStreakEl.textContent = state.streak;
      playerNameInput.value = localStorage.getItem(NAME_KEY) || '';
      gameOverModal.classList.add('show');
    }

    function resetPuzzleUi() {
      solvedAreaEl.innerHTML = '';
      gridEl.innerHTML = '';
      clearSelection();
      state.wrongCombos.clear();
      state.mistakesLeft = 4;
      state.wrongGuesses = 0;
      renderMistakes();
      setFeedback('');
    }

    async function loadNextPuzzle() {
      resetPuzzleUi();
      const p = chooseNextPuzzle();
      const tiles = shuffleArray(buildTilesFromCategories(p.categories));
      const solvedCats = [];
      const unsolvedCats = () => p.categories.filter(c => !solvedCats.includes(c));

      state.current = { id: p.id, categories: p.categories, tiles, solvedCats, unsolvedCats };

      renderGrid(tiles);
      updateHud();
    }

    function startRun() {
      // Reset run-level state
      state.totalScore = 0;
      state.puzzlesSolved = 0;
      state.streak = 0;
      state.usedPuzzleIds.clear();
      updateHud();
      gameOverModal.classList.remove('show');
      loadNextPuzzle();
    }

    function renderLeaderboard() {
      const list = loadLeaderboard();
      list.sort((a,b) => b.score - a.score || b.streak - a.streak || a.createdAt - b.createdAt);
      const rows = list.slice(0, 10).map((e, i) => `
        <tr>
          <td>${i+1}</td>
          <td>${escapeHtml(e.name)}</td>
          <td>${e.score}</td>
          <td>${e.streak}</td>
          <td>${new Date(e.createdAt).toLocaleString()}</td>
        </tr>
      `).join('');
      const table = `
        <table aria-label="Leaderboard">
          <thead>
            <tr><th>#</th><th>Name</th><th>Total score</th><th>Streak</th><th>Date</th></tr>
          </thead>
          <tbody>${rows || `<tr><td colspan="5" style="text-align:center; padding:16px;">No scores yet</td></tr>`}</tbody>
        </table>`;
      $('#leaderboardTableWrap').innerHTML = table;
    }

    function escapeHtml(str) {
      return String(str).replace(/[&<>"]+/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[s]));
    }

    function submitScore() {
      const name = playerNameInput.value.trim() || 'Anonymous';
      localStorage.setItem(NAME_KEY, name);
      const list = loadLeaderboard();
      list.push({ name, score: state.totalScore, streak: state.streak, createdAt: Date.now() });
      saveLeaderboard(list);
      renderLeaderboard();
      showToast('Score submitted!');
      gameOverModal.classList.remove('show');
    }

    // --- Event wiring ---
    submitBtn.addEventListener('click', submitSelection);
    shuffleBtn.addEventListener('click', shuffleGrid);
    clearBtn.addEventListener('click', clearSelection);
    submitScoreBtn.addEventListener('click', submitScore);
    playAgainBtn.addEventListener('click', startRun);

    // Keyboard support: arrow nav and space/enter to toggle
    document.addEventListener('keydown', (e) => {
      const tiles = $$('.tile');
      const focusable = tiles.filter(t => !t.classList.contains('locked'));
      const idx = focusable.indexOf(document.activeElement);
      const cols = 4;
      if (e.key === 'ArrowRight' && idx >= 0) { e.preventDefault(); (focusable[idx+1]||focusable[idx]).focus(); }
      if (e.key === 'ArrowLeft'  && idx >= 0) { e.preventDefault(); (focusable[idx-1]||focusable[idx]).focus(); }
      if (e.key === 'ArrowDown'  && idx >= 0) { e.preventDefault(); (focusable[idx+cols]||focusable[idx]).focus(); }
      if (e.key === 'ArrowUp'    && idx >= 0) { e.preventDefault(); (focusable[idx-cols]||focusable[idx]).focus(); }
      if ((e.key === 'Enter' || e.key === ' ') && document.activeElement?.classList.contains('tile')) {
        e.preventDefault(); document.activeElement.click();
      }
    });

    // Init
    renderLeaderboard();
    startRun();
  </script>
</body>
</html>
