<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Connections — Endless Mode</title>
  <!--
    Endless Connections with Supabase leaderboard (client-side only).
    - Per puzzle: 4 mistakes; each wrong (incl. "One away!") = –25 points.
    - Repeated wrong combination: toast + NO penalty.
    - Streak = puzzles solved in this run. Shows live + on leaderboard.
    - Anti-repeat of puzzle IDs within a run.
    - Win/Lose overlays show placeholder images for 2s.
    - Leaderboard: localStorage fallback OR Supabase if configured.
    - Puzzles come from puzzles.js (window.CONNECTIONS_PUZZLES).
  -->

  <style>
    :root {
      /* Tweak if needed to match NYT Connections vibe */
      --bg: #f6f6f5;
      --text: #111;
      --muted: #777;
      --tile-bg: #e7e7e7;
      --tile-border: #d0d0d0;
      --tile-hover: #dcdcdc;
      --tile-selected-bg: #333;
      --tile-selected-text: #fff;
      --btn-bg: #111;
      --btn-text: #fff;
      --btn-disabled-bg: #bbb;
      --btn-disabled-text: #fff;

      /* Category colours */
      --cat-yellow: #f7da21;
      --cat-green: #6ac36f;
      --cat-blue:  #6aa7ff;
      --cat-purple:#b084f9;
    }

    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg);
      color: var(--text);
      display: grid;
      grid-template-rows: auto 1fr auto;
      min-height: 100vh;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px clamp(12px, 4vw, 32px);
      border-bottom: 1px solid #e2e2e2;
      gap: 12px;
    }
    .brand { font-weight: 800; letter-spacing: 0.5px; font-size: 20px; }
    .status { display: flex; gap: 14px; font-size: 14px; color: var(--muted); }
    .status b { color: var(--text); }

    main { width: min(900px, 92vw); margin: 18px auto 28px; }

    #solvedArea { display: grid; gap: 10px; margin-bottom: 16px; }
    .solved-row {
      display: grid;
      grid-template-columns: 140px 1fr;
      align-items: center;
      border-radius: 10px;
      padding: 8px 10px;
      font-weight: 600;
      color: #111;
      box-shadow: 0 1px 0 rgba(0,0,0,0.05);
    }
    .solved-row .label { opacity: 0.9; }
    .solved-row .words { opacity: 0.95; }

    .cat-yellow { background: color-mix(in oklab, var(--cat-yellow) 45%, white); }
    .cat-green  { background: color-mix(in oklab, var(--cat-green) 45%, white); }
    .cat-blue   { background: color-mix(in oklab, var(--cat-blue) 45%, white); }
    .cat-purple { background: color-mix(in oklab, var(--cat-purple) 45%, white); }

    .grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
    .tile {
      user-select: none;
      background: var(--tile-bg);
      border: 1px solid var(--tile-border);
      border-radius: 10px;
      padding: 18px 10px;
      text-align: center;
      font-weight: 700;
      letter-spacing: 0.2px;
      cursor: pointer;
      transition: transform 120ms ease, background 120ms ease, color 120ms ease, border-color 120ms ease;
    }
    .tile:hover { background: var(--tile-hover); }
    .tile.selected { background: var(--tile-selected-bg); color: var(--tile-selected-text); border-color: #000; transform: translateY(-1px); }
    .tile.locked { opacity: 0.35; pointer-events: none; }

    .controls { display: flex; gap: 10px; margin: 16px 0 10px; }
    button { appearance: none; border: none; background: var(--btn-bg); color: var(--btn-text); padding: 10px 14px; border-radius: 999px; font-weight: 700; letter-spacing: 0.2px; cursor: pointer; }
    button.secondary { background: #ddd; color: #111; }
    button:disabled { background: var(--btn-disabled-bg); color: var(--btn-disabled-text); cursor: not-allowed; }

    .hud { display: flex; align-items: center; justify-content: space-between; gap: 12px; margin-top: 6px; }

    .mistakes { display: flex; align-items: center; gap: 6px; }
    .dot { width: 10px; height: 10px; border-radius: 50%; background: #ccc; }
    .dot.live { background: #111; }

    #feedback { min-height: 24px; margin-top: 8px; color: var(--muted); font-weight: 600; }

    .toast { position: fixed; left: 50%; transform: translateX(-50%); bottom: 24px; background: #111; color: #fff; padding: 10px 14px; border-radius: 999px; font-weight: 700; letter-spacing: 0.2px; opacity: 0; pointer-events: none; transition: opacity 200ms ease; }
    .toast.show { opacity: 1; }

    .shake { animation: shake 250ms ease; }
    @keyframes shake { 0%{ transform: translateX(0);}25%{ transform: translateX(-3px);}50%{ transform: translateX(3px);}75%{ transform: translateX(-3px);}100%{ transform: translateX(0);} }

    .overlay { position: fixed; inset: 0; display: grid; place-items: center; background: rgba(0,0,0,0.35); opacity: 0; pointer-events: none; transition: opacity 200ms ease; }
    .overlay img { width: min(60vmin, 360px); height: auto; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.35); }
    .overlay.show { opacity: 1; pointer-events: auto; }

    .modal { position: fixed; inset: 0; display: grid; place-items: center; background: rgba(0,0,0,0.15); opacity: 0; pointer-events: none; transition: opacity 200ms ease; }
    .modal.show { opacity: 1; pointer-events: auto; }
    .card { width: min(520px, 92vw); background: #fff; border-radius: 16px; padding: 18px; box-shadow: 0 8px 40px rgba(0,0,0,0.18); }
    .card h2 { margin: 6px 0 12px; }
    .row { display: flex; gap: 12px; align-items: center; justify-content: space-between; }
    .field { display: grid; gap: 6px; margin: 10px 0; }
    input[type="text"] { padding: 10px 12px; border-radius: 10px; border: 1px solid #ccc; font-size: 15px; }

    #leaderboard { margin: 32px 0 24px; }
    #leaderboard h3 { margin-bottom: 8px; }
    table { width: 100%; border-collapse: collapse; background: #fff; border-radius: 12px; overflow: hidden; }
    th, td { padding: 10px 12px; border-bottom: 1px solid #eee; text-align: left; font-size: 14px; }
    th { background: #f1f1f1; font-weight: 800; }

    footer { padding: 16px clamp(12px, 4vw, 32px); border-top: 1px solid #e2e2e2; color: var(--muted); font-size: 13px; }
  </style>
</head>
<body>
  <header>
    <div class="brand">Connections</div>
    <div class="status" aria-live="polite">
      <div>Total score: <b id="totalScore">0</b></div>
      <div>Streak: <b id="streak">0</b></div>
      <div>Puzzles solved: <b id="puzzlesSolved">0</b></div>
    </div>
  </header>

  <main>
    <div id="solvedArea" aria-live="polite"></div>

    <section class="grid" id="grid" aria-label="Word tiles"></section>

    <div class="controls">
      <button class="secondary" id="shuffleBtn" aria-label="Shuffle tiles">Shuffle</button>
      <button class="secondary" id="clearBtn" aria-label="Clear selection">Deselect</button>
      <button id="submitBtn" disabled aria-label="Submit selection">Submit</button>
    </div>

    <div class="hud">
      <div class="mistakes" id="mistakes" aria-label="Mistakes remaining">
        <div class="dot live"></div>
        <div class="dot live"></div>
        <div class="dot live"></div>
        <div class="dot live"></div>
      </div>
      <div id="feedback" role="status" aria-live="polite"></div>
    </div>

    <section id="leaderboard">
      <h3>Leaderboard</h3>
      <div id="leaderboardTableWrap"></div>
    </section>
  </main>

  <div id="winOverlay" class="overlay" aria-hidden="true">
    <img id="puzzleWinImage" src="win-placeholder.png" alt="Puzzle solved" />
  </div>
  <div id="loseOverlay" class="overlay" aria-hidden="true">
    <img id="gameOverImage" src="gameover-placeholder.png" alt="Game over" />
  </div>

  <div id="gameOverModal" class="modal" aria-hidden="true">
    <div class="card" role="dialog" aria-labelledby="gomTitle" aria-describedby="gomDesc">
      <h2 id="gomTitle">Run complete</h2>
      <p id="gomDesc" class="muted">Submit your score to the leaderboard.</p>
      <div class="row">
        <div><strong>Total score:</strong> <span id="finalTotalScore">0</span></div>
        <div><strong>Streak:</strong> <span id="finalStreak">0</span></div>
      </div>
      <div class="field">
        <label for="playerName">Your name</label>
        <input id="playerName" type="text" placeholder="e.g., Alex" maxlength="24" />
      </div>
      <div class="row">
        <button id="submitScoreBtn">Submit to Leaderboard</button>
        <button class="secondary" id="playAgainBtn">Play again</button>
      </div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <!-- Optional: set these on the page before loading index.js -->
    <script>
    window.SUPABASE_URL = "https://tralparxinmltofaiclh.supabase.co";
    window.SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRyYWxwYXJ4aW5tbHRvZmFpY2xoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ5MTcxOTAsImV4cCI6MjA3MDQ5MzE5MH0.Y0wV1-nHtFihiRw5xokkNYa9dxCRfMYhlMQpTm_p4Gw";
  </script>
 

  <!-- Supabase client (v2) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- Puzzles file (defines window.CONNECTIONS_PUZZLES) -->
  <script src="puzzles.js"></script>

  <script>
    // --- Utilities ---
    const $ = (sel, root=document) => root.querySelector(sel);
    const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
    const shuffleArray = (arr) => arr.map(v=>[Math.random(), v]).sort((a,b)=>a[0]-b[0]).map(p=>p[1]);
    const sleep = (ms) => new Promise(r=>setTimeout(r, ms));
    const escapeHtml = (str) => String(str).replace(/[&<>\"]/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[s]));

    function keyFromWords(words) { return words.slice().sort().join('|'); }

    // --- State ---
    const state = {
      totalScore: 0,
      puzzlesSolved: 0,
      streak: 0,
      current: null,
      selectedIds: new Set(),
      wrongCombos: new Set(),
      mistakesLeft: 4,
      wrongGuesses: 0,
      usedPuzzleIds: new Set(),
    };

    // --- DOM refs ---
    const gridEl = $('#grid');
    const solvedAreaEl = $('#solvedArea');
    const feedbackEl = $('#feedback');
    const mistakesEl = $('#mistakes');
    const submitBtn = $('#submitBtn');
    const shuffleBtn = $('#shuffleBtn');
    const clearBtn = $('#clearBtn');

    const totalScoreEl = $('#totalScore');
    const puzzlesSolvedEl = $('#puzzlesSolved');
    const streakEl = $('#streak');

    const winOverlay = $('#winOverlay');
    const loseOverlay = $('#loseOverlay');
    const gameOverModal = $('#gameOverModal');
    const finalTotalScoreEl = $('#finalTotalScore');
    const finalStreakEl = $('#finalStreak');
    const playerNameInput = $('#playerName');
    const submitScoreBtn = $('#submitScoreBtn');
    const playAgainBtn = $('#playAgainBtn');
    const toastEl = $('#toast');

    // --- Leaderboard storage: local fallback + Supabase ---
    const LB_KEY = 'connections_leaderboard_v1';
    const NAME_KEY = 'connections_player_name_v1';
    const LB_TABLE = 'connections_leaderboard';

    // Supabase init (client-side)
    const SUPABASE_URL = window.SUPABASE_URL || '';
    const SUPABASE_ANON_KEY = window.SUPABASE_ANON_KEY || '';
    const supabase = (SUPABASE_URL && SUPABASE_ANON_KEY && window.supabase)
      ? window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY)
      : null;

    // Subscribe to realtime leaderboard updates (optional but nice)
    function subscribeLeaderboard() {
      if (!supabase) return;
      try {
        supabase.channel('lb-updates')
          .on('postgres_changes', { event: '*', schema: 'public', table: LB_TABLE }, () => renderLeaderboard())
          .subscribe();
      } catch (e) { console.warn('Realtime subscribe failed', e); }
    }

    function loadLeaderboardLocal() {
      try { return JSON.parse(localStorage.getItem(LB_KEY) || '[]'); } catch { return []; }
    }
    function saveLeaderboardLocal(list) {
      localStorage.setItem(LB_KEY, JSON.stringify(list));
    }

    function showToast(msg, ms=1400) {
      toastEl.textContent = msg;
      toastEl.classList.add('show');
      setTimeout(()=>toastEl.classList.remove('show'), ms);
    }

    function updateHud() {
      totalScoreEl.textContent = state.totalScore;
      puzzlesSolvedEl.textContent = state.puzzlesSolved;
      streakEl.textContent = state.streak;
    }

    function renderMistakes() {
      const dots = $$('.dot', mistakesEl);
      dots.forEach((d, i) => d.classList.toggle('live', i < state.mistakesLeft));
    }

    function setFeedback(msg) { feedbackEl.textContent = msg || ''; }

    function clearSelection() {
      state.selectedIds.clear();
      $$('.tile').forEach(t => t.classList.remove('selected'));
      submitBtn.disabled = true;
    }

    function buildTilesFromCategories(categories) {
      const tiles = [];
      const counts = new Map();
      for (const cat of categories) {
        for (const w of cat.words) {
          const up = String(w).toUpperCase();
          const n = (counts.get(up) || 0) + 1;
          counts.set(up, n);
          tiles.push({ id: `${up}#${n}`, text: up });
        }
      }
      return tiles;
    }

    function chooseNextPuzzle() {
      const pool = window.CONNECTIONS_PUZZLES || [];
      if (!pool.length) throw new Error('No puzzles available.');
      const unseen = pool.filter(p => !state.usedPuzzleIds.has(p.id));
      const bag = unseen.length ? unseen : pool;
      const pick = bag[Math.floor(Math.random()*bag.length)];
      if (!unseen.length) state.usedPuzzleIds.clear();
      state.usedPuzzleIds.add(pick.id);
      return pick;
    }

    function colorClass(color) {
      switch((color||'').toLowerCase()) {
        case 'yellow': return 'cat-yellow';
        case 'green':  return 'cat-green';
        case 'blue':   return 'cat-blue';
        case 'purple': return 'cat-purple';
        default:       return 'cat-yellow';
      }
    }

    function renderSolvedRow(cat) {
      const row = document.createElement('div');
      row.className = `solved-row ${colorClass(cat.color)}`;
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = cat.name;
      const words = document.createElement('div');
      words.className = 'words';
      words.textContent = cat.words.join(' • ');
      row.append(label, words);
      solvedAreaEl.appendChild(row);
    }

    function renderGrid(tiles) {
      gridEl.innerHTML = '';
      tiles.forEach(t => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'tile';
        btn.dataset.id = t.id;
        btn.dataset.word = t.text;
        btn.textContent = t.text;
        btn.addEventListener('click', () => onTileClick(btn));
        gridEl.appendChild(btn);
      });
    }

    function shuffleGrid() {
      const children = Array.from(gridEl.children);
      const shuffled = shuffleArray(children);
      gridEl.innerHTML = '';
      shuffled.forEach(el => gridEl.appendChild(el));
    }

    function onTileClick(btn) {
      if (btn.classList.contains('locked')) return;
      const id = btn.dataset.id;
      if (state.selectedIds.has(id)) {
        state.selectedIds.delete(id);
        btn.classList.remove('selected');
      } else {
        if (state.selectedIds.size >= 4) return;
        state.selectedIds.add(id);
        btn.classList.add('selected');
      }
      submitBtn.disabled = state.selectedIds.size !== 4;
    }

    function getSelectedWords() { return Array.from(state.selectedIds).map(id => id.split('#')[0]); }

    function lockCategoryWords(words) {
      const wordSet = new Set(words.map(w => String(w).toUpperCase()));
      $$('.tile').forEach(t => { if (wordSet.has(t.dataset.word)) t.classList.add('locked'); });
    }

    function allCategoriesSolved() { return state.current.solvedCats.length === 4; }

    function anyOneAway(selSet) {
      for (const cat of state.current.unsolvedCats()) {
        const inter = cat.words.filter(w => selSet.has(String(w).toUpperCase())).length;
        if (inter === 3) return true;
      }
      return false;
    }

    function shakeSelection() {
      $$('.tile.selected').forEach(t => { t.classList.remove('shake'); void t.offsetWidth; t.classList.add('shake'); });
    }

    async function submitSelection() {
      if (state.selectedIds.size !== 4) return;
      const words = getSelectedWords();
      const key = keyFromWords(words);

      if (state.wrongCombos.has(key)) {
        showToast('Already guessed this combination');
        shakeSelection();
        return; // no penalty
      }

      const match = state.current.unsolvedCats().find(cat => {
        const a = new Set(cat.words.map(w => String(w).toUpperCase()));
        return words.every(w => a.has(String(w).toUpperCase()));
      });

      if (match) {
        renderSolvedRow(match);
        lockCategoryWords(match.words);
        state.current.solvedCats.push(match);
        setFeedback(`${match.name}`);
        clearSelection();

        if (allCategoriesSolved()) {
          const puzzleScore = Math.max(0, 100 - 25 * state.wrongGuesses);
          state.totalScore += puzzleScore;
          state.puzzlesSolved += 1;
          state.streak += 1;
          updateHud();
          await showWinOverlayThenNext();
        }
        return;
      }

      const selSet = new Set(words.map(w => String(w).toUpperCase()));
      const isOneAway = anyOneAway(selSet);
      state.wrongCombos.add(key);
      state.wrongGuesses += 1;
      state.mistakesLeft -= 1;
      renderMistakes();
      setFeedback(isOneAway ? 'One away!' : 'Incorrect group.');
      shakeSelection();
      clearSelection();

      if (state.mistakesLeft <= 0) {
        await showLoseOverlayThenGameOver();
      }
    }

    async function showWinOverlayThenNext() {
      winOverlay.classList.add('show');
      await sleep(2000);
      winOverlay.classList.remove('show');
      await loadNextPuzzle();
    }

    async function showLoseOverlayThenGameOver() {
      loseOverlay.classList.add('show');
      await sleep(2000);
      loseOverlay.classList.remove('show');
      finalTotalScoreEl.textContent = state.totalScore;
      finalStreakEl.textContent = state.streak;
      playerNameInput.value = localStorage.getItem(NAME_KEY) || '';
      gameOverModal.classList.add('show');
    }

    function resetPuzzleUi() {
      solvedAreaEl.innerHTML = '';
      gridEl.innerHTML = '';
      clearSelection();
      state.wrongCombos.clear();
      state.mistakesLeft = 4;
      state.wrongGuesses = 0;
      renderMistakes();
      setFeedback('');
    }

    async function loadNextPuzzle() {
      resetPuzzleUi();
      const p = chooseNextPuzzle();
      const tiles = shuffleArray(buildTilesFromCategories(p.categories));
      const solvedCats = [];
      const unsolvedCats = () => p.categories.filter(c => !solvedCats.includes(c));
      state.current = { id: p.id, categories: p.categories, tiles, solvedCats, unsolvedCats };
      renderGrid(tiles);
      updateHud();
    }

    function startRun() {
      state.totalScore = 0;
      state.puzzlesSolved = 0;
      state.streak = 0;
      state.usedPuzzleIds.clear();
      updateHud();
      gameOverModal.classList.remove('show');
      loadNextPuzzle();
    }

    async function fetchLeaderboard(limit=10) {
      if (!supabase) {
        const list = loadLeaderboardLocal();
        list.sort((a,b) => b.score - a.score || b.streak - a.streak || a.createdAt - b.createdAt);
        return list.slice(0, limit);
      }
      const { data, error } = await supabase
        .from(LB_TABLE)
        .select('name, score, streak, created_at')
        .order('score', { ascending: false })
        .order('streak', { ascending: false })
        .order('created_at', { ascending: true })
        .limit(limit);
      if (error) { console.warn('Leaderboard fetch error', error); return []; }
      return data.map(d => ({ name: d.name, score: d.score, streak: d.streak, createdAt: new Date(d.created_at).getTime() }));
    }

    async function renderLeaderboard() {
      const rowsData = await fetchLeaderboard(10);
      const rows = rowsData.map((e, i) => `
        <tr>
          <td>${i+1}</td>
          <td>${escapeHtml(e.name)}</td>
          <td>${e.score}</td>
          <td>${e.streak}</td>
          <td>${new Date(e.createdAt).toLocaleString()}</td>
        </tr>
      `).join('');
      const table = `
        <table aria-label="Leaderboard">
          <thead>
            <tr><th>#</th><th>Name</th><th>Total score</th><th>Streak</th><th>Date</th></tr>
          </thead>
          <tbody>${rows || `<tr><td colspan="5" style="text-align:center; padding:16px;">No scores yet</td></tr>`}</tbody>
        </table>`;
      $('#leaderboardTableWrap').innerHTML = table;
    }

    async function submitScore() {
      const name = (playerNameInput.value || '').trim() || 'Anonymous';
      localStorage.setItem(NAME_KEY, name);

      if (supabase) {
        const { error } = await supabase.from(LB_TABLE).insert({ name, score: state.totalScore, streak: state.streak });
        if (error) {
          console.warn('Supabase insert failed', error);
          showToast('Submit failed — saved locally.');
          const list = loadLeaderboardLocal();
          list.push({ name, score: state.totalScore, streak: state.streak, createdAt: Date.now() });
          saveLeaderboardLocal(list);
        } else {
          showToast('Score submitted!');
        }
      } else {
        const list = loadLeaderboardLocal();
        list.push({ name, score: state.totalScore, streak: state.streak, createdAt: Date.now() });
        saveLeaderboardLocal(list);
        showToast('Score saved locally');
      }

      gameOverModal.classList.remove('show');
      renderLeaderboard();
    }

    // --- Event wiring ---
    submitBtn.addEventListener('click', submitSelection);
    shuffleBtn.addEventListener('click', shuffleGrid);
    clearBtn.addEventListener('click', clearSelection);
    submitScoreBtn.addEventListener('click', submitScore);
    playAgainBtn.addEventListener('click', startRun);

    // Keyboard support
    document.addEventListener('keydown', (e) => {
      const tiles = $$('.tile');
      const focusable = tiles.filter(t => !t.classList.contains('locked'));
      const idx = focusable.indexOf(document.activeElement);
      const cols = 4;
      if (e.key === 'ArrowRight' && idx >= 0) { e.preventDefault(); (focusable[idx+1]||focusable[idx]).focus(); }
      if (e.key === 'ArrowLeft'  && idx >= 0) { e.preventDefault(); (focusable[idx-1]||focusable[idx]).focus(); }
      if (e.key === 'ArrowDown'  && idx >= 0) { e.preventDefault(); (focusable[idx+cols]||focusable[idx]).focus(); }
      if (e.key === 'ArrowUp'    && idx >= 0) { e.preventDefault(); (focusable[idx-cols]||focusable[idx]).focus(); }
      if ((e.key === 'Enter' || e.key === ' ') && document.activeElement?.classList.contains('tile')) {
        e.preventDefault(); document.activeElement.click();
      }
    });

    // Init
    (async function init(){
      subscribeLeaderboard();
      await renderLeaderboard();
      startRun();
    })();
  </script>
</body>
</html>

